# Docker Compose Override for Production
# Use: docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

version: '3.8'

services:
  postgres:
    # Production-ready PostgreSQL configuration
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      # Additional production tuning
      POSTGRES_SHARED_BUFFERS: 512MB
      POSTGRES_EFFECTIVE_CACHE_SIZE: 2GB
      POSTGRES_WORK_MEM: 16MB
      POSTGRES_MAINTENANCE_WORK_MEM: 128MB
      POSTGRES_MAX_CONNECTIONS: 200
    # Don't expose ports directly in production (use reverse proxy)
    ports: []
    command: >
      postgres
      -c max_connections=200
      -c shared_buffers=512MB
      -c effective_cache_size=2GB
      -c maintenance_work_mem=128MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=16MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
      -c max_worker_processes=4
      -c max_parallel_workers_per_gather=2
      -c max_parallel_workers=4
      -c max_parallel_maintenance_workers=2
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G

  redis:
    restart: always
    # Stronger password required
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --appendonly yes
      --appendfsync everysec
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --save 900 1
      --save 300 10
      --save 60 10000
      --tcp-backlog 511
      --timeout 300
      --tcp-keepalive 300
      --maxclients 10000
    # Don't expose port in production
    ports: []
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M

  app:
    restart: always
    # Production environment
    environment:
      - ENV=production
      - LOG_LEVEL=info
      - LOG_FORMAT=json
      # All other vars from base compose + .env
    # Don't expose port directly (use reverse proxy)
    ports: []
    # Read-only root filesystem for security
    read_only: false  # Set to true if app doesn't need write access
    # Run as non-root user (already configured in Dockerfile)
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 4G
        reservations:
          cpus: '2'
          memory: 2G
      # Optional: For Docker Swarm
      replicas: 1
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      rollback_config:
        parallelism: 1
        delay: 5s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s

  backup:
    restart: always
    # Production backup runs daily
    environment:
      BACKUP_RETENTION_DAYS: ${BACKUP_RETENTION_DAYS:-7}
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G

  # Optional: Reverse proxy with Let's Encrypt
  # Uncomment if you want to add Nginx/Traefik
  # nginx:
  #   image: nginx:alpine
  #   container_name: nieuws-scraper-nginx
  #   restart: always
  #   ports:
  #     - "80:80"
  #     - "443:443"
  #   volumes:
  #     - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
  #     - ./nginx/certs:/etc/nginx/certs:ro
  #   depends_on:
  #     - app
  #   networks:
  #     - nieuws-scraper-network